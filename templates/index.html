<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />

    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>Virtual HOTAS</title>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65"
      crossorigin="anonymous"
    />
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.5.0/nouislider.css"
      rel="stylesheet"
    />
    <style>
      .grid-container {
        display: grid;

        grid-template-rows: 1fr;
        grid-template-columns: 1fr 0.25fr 1fr;

        grid-template-areas: "leftRudder fullScreen rightRudder";

        gap: 10px;
        height: calc(100vh - 10px);
        padding: 10px;
        place-items: stretch;
      }

      .left-rudder {
        grid-area: leftRudder;
        justify-self: stretch;
      }
      .fullscreen {
        grid-area: fullScreen;
        justify-self: stretch;
      }
      .right-rudder {
        grid-area: rightRudder;
        justify-self: stretch;
      }

      .button {
        width: 100%;
        height: 100%;
        font-size: large;
      }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
  </head>
  <body>
    <div class="grid-container">
      <button
        class="leftRudder btn btn-primary button"
        onpointerdown="buttonPress(21)"
        onpointerup="buttonRelease(21)"
      >
        Left Rudder
      </button>

      <button class="fullScreen btn btn-primary button" onpointerdown="toggleFullscreen()">
        Full Screen
      </button>
      <button
        class="rightRudder btn btn-primary button"
        onpointerdown="buttonPress(22)"
        onpointerup="buttonRelease(22)"
      >
        Right Rudder
      </button>
    </div>

    <script>
      // Initialize the socket
      const socket = io.connect("http://" + document.domain + ":" + location.port);

      // Initialize default values
      let buttonValuesInit = Array(31).fill(0);
      let orientationInit = Array(5).fill(0);
      let gamepadAttached = false;

      /**
       * Compare arrays
       * Used to check if values have changed from the initialized values
       */
      const compareArrays = (a, b) =>
        a.length === b.length && a.every((element, index) => element === b[index]);

      /**
       * If gamepad is connected socket.emit status and hide orientation values in UI
       */
      window.addEventListener("gamepadconnected", (event) => {
        const gp = event.gamepad;
        // document.getElementById("status").innerText = `Gamepad connected: ${gp.id}`;
        gamepadAttached = true;
        updateStatus();
        socket.emit("gamepadConnection", {
          connected: true,
        });
      });

      /**
       * If gamepad is disconnected socket.emit status show hide orientation values in UI
       */
      window.addEventListener("gamepaddisconnected", (event) => {
        gamepadAttached = false;
        socket.emit("gamepadConnection", {
          connected: false,
        });
      });

      
      /**
       * Logic to get the button and axes data from the gamepad.
       */
      function updateStatus() {
        const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];

        for (let i = 0; i < gamepads.length; i++) {
          const gp = gamepads[i];
          if (gp) {
            const buttonValues = gp.buttons.map((button) => parseInt(button.value));
            if (compareArrays(buttonValues, buttonValuesInit)) {
            } else {
              gamepadButton(buttonValues);
              buttonValuesInit = buttonValues;
            }
            // document.getElementById("axisinfo").innerText = buttonValues;
            let data = {
              yaw: -gp.buttons[6].value + gp.buttons[7].value,
              pitch: gp.axes[1],
              roll: gp.axes[0],
              headYaw: gp.axes[2],
              headPitch: gp.axes[3],
            };
            if (compareArrays(Object.values(data), orientationInit)) {
            } else {
              orientationInit = Object.values(data);
              socket.emit("orientation", data);
            }
            // document.getElementById("axisinfo").innerText += orientationInit;
          }
        }
        requestAnimationFrame(updateStatus);
      }

      /**
       * Get the current orientation and set it as home position.
       */
      function homeOrientation() {
        if (window.DeviceOrientationEvent) {
          let once = false;

          window.addEventListener("deviceorientationabsolute", function (event) {
            if (!once) {
              let data = {
                yaw: event.alpha,
                pitch: event.beta,
                roll: event.gamma,
              };
              socket.emit("orientationHOME", data);
              once = true;
            }
          });
        } else {
          alert("Device does not support DeviceOrientationEvent");
        }
      }

      /**
       * Handle button presses from the UI
       */
      function buttonPress(data) {
        socket.emit("button_press", {
          button: data,
        });
      }

      /**
       * Handle button release from the UI
       */
      function buttonRelease(data) {
        socket.emit("button_release", {
          button: data,
        });
      }

      /**
       * Handle button presses on the gamepad
       */
      function gamepadButton(data) {
        socket.emit("gamepadButton", {
          gamepadButtonData: data,
        });
      }

      /**
       * Event listener for joystick update acknowledgement
       */
      socket.on("orientation_updated", function (data) {
        console.log(data);
        let pitch_label = document.getElementById("pitch");
        pitch_label.textContent = Math.round(data.pitch);
        let roll_label = document.getElementById("roll");
        roll_label.textContent = Math.round(data.roll);
        let yaw_label = document.getElementById("yaw");
        yaw_label.textContent = Math.round(data.yaw);
      });

      /**
       * Toggle full screen
       */
      function toggleFullscreen() {
        if (document.fullscreenElement) {
          document.exitFullscreen().catch((err) => console.log(err));
        } else {
          document.documentElement.requestFullscreen().catch((err) => console.log(err));
        }
      }
    </script>
  </body>
</html>
